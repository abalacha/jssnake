<!DOCTYPE html>
<html>
<body>

<canvas id="board" width="500" height="700">
</canvas>
    
<script>

// Get the canvas and the context
let c = document.getElementById("board");
let ctx = c.getContext("2d");
ctx.font = '14px Courier';
ctx.textBaseline = 'top';
ctx.textAlign = 'left';

// Number of columns and rows the board has
const BOARD_SIZE = 50;    // Rows inrease in Y axis - columns in X axis
const RIGHT = 0;
const UP = 1;
const LEFT = 2;
const DOWN = 3;
const ROW_IDX = 0;
const COL_IDX = 1;

// Board values and colors
const EMPTY = 0;
const BORDER = 1;
const LIVE_SNAKE = 2;
const DEAD_SNAKE = 3;
const COLOR_LOOKUP = ['lightgray', 'purple', 'blue', 'black'];

// Pre-calculate constants
let pixels_per_cell = c.width / BOARD_SIZE;
let last_board_index = BOARD_SIZE - 1;  // Arrays index from 0 to (n-1).
let show_debug = false;

// Top level variables
let board = new Array(BOARD_SIZE);
let snake_direction = 2; // 0 right, 1 up, 2 left, 3 down
let snake_dead = false;
let snake = [];

function copy_snake_to_board(status) {
    for (let snake_idx = 0; snake_idx < snake.length; snake_idx++) {
        board[snake[snake_idx][ROW_IDX]][snake[snake_idx][COL_IDX]] = status;
    }
}

function Initialize_snake() {
    // Snake coordinates in [ row, col ]
    snake = [
        [15, 13],
        [15, 14],
        [15, 15],
        [15, 16],
        [15, 17],
    ];
}

function initialize_board() {
    // Initialize the Board
    for (let row = 0 ; row < BOARD_SIZE; row++ ) {
        board[row] = new Array(BOARD_SIZE);
        for (let col = 0; col < BOARD_SIZE; col++) {
            let board_value = EMPTY;
            // For first and last rows and columns set board to 1.
            if ((row == 0) || (row == last_board_index) || (col == 0) || (col == last_board_index)) {
                board_value = BORDER;
            }
            board[row][col] = board_value;
        }
    }
}

function initialize_level() {
    // Put a small obstacle on the board - Vertical line at column 20.
    for (let row = 20; row < 25; row++ ) {
        board[row][20] = 1; 
    }
}

// Calculate the snake's new position and update the baord
function snake_update() {
    // If the snake is dead, then don't have to do anything.
    if (snake_dead) {
        return;
    }

    let new_head = new Array(2);    // create a new head for the snake
    new_head[ROW_IDX] = snake[0][ROW_IDX];
    new_head[COL_IDX] = snake[0][COL_IDX];
    switch (snake_direction) {
        case RIGHT:
            new_head[COL_IDX] ++;
            break;
        case UP:
            new_head[ROW_IDX] --;
            break;
        case LEFT:
            new_head[COL_IDX] --;
            break;
        case DOWN:
            new_head[ROW_IDX] ++;
            break;
    }
    // check if the new head would be in an obstacle
    board_value = board[new_head[ROW_IDX]][new_head[COL_IDX]]
    if (board_value == EMPTY) {     // The board is empty. Move the snake.
        snake.unshift(new_head);    // Add the new head to the snake.
        board[snake[0][ROW_IDX]][snake[0][COL_IDX]] = LIVE_SNAKE;

        let tail_end = snake.pop();                             // Remove the tail
        board[tail_end[ROW_IDX]][tail_end[COL_IDX]] = EMPTY;    // Set the tail position as empty

    } else {  // snake is dead
        snake_dead = true;
        copy_snake_to_board(DEAD_SNAKE);
        // plan sad audio
        var clang = new Audio('clang.m4a');
        clang.play();
    }
}

// function to draw a rectangle at x, y of width pixels_per_cell
function draw_rect(x, y) {
    ctx.rect(x * pixels_per_cell, y * pixels_per_cell, pixels_per_cell, pixels_per_cell);
}

// Draw the board and snake on the canvas
function refresh_board() {    
    // Draw the board
    for (let row = 0 ; row < BOARD_SIZE; row++ ) {
        for (let col = 0; col < BOARD_SIZE; col++) {
            ctx.beginPath();
            ctx.fillStyle = COLOR_LOOKUP[board[row][col]];
            draw_rect(col, row);
            ctx.fill();
        }
    }

    ctx.fillStyle = 'white';
    if (show_debug) {
        ctx.fillStyle = 'black';
    }
    // Draw the debug Area
    ctx.beginPath();
    ctx.rect(0, 500, 500, 200);
    ctx.fill();

    if (show_debug) {
        // Debug Details
        ctx.fillStyle = "lightgreen";
        ctx.fillText('direction: ' + snake_direction, 0, 510);
        ctx.fillText('snake_dead: ' + snake_dead, 0, 530);
        ctx.fillText('snake_head: ' + snake[0][0] + ',' + snake[0][1], 0, 550);
    }
}

function keyHandler(event) {
    switch (event.key) {
        case "ArrowLeft":
            if ((snake_direction == UP) || (snake_direction == DOWN)) {
                snake_direction = LEFT;
            }
            break;
        case "ArrowRight":
            if ((snake_direction == UP) || (snake_direction == DOWN)) {
                snake_direction = RIGHT;
            }
            break;
        case "ArrowUp":
            if ((snake_direction == RIGHT) || (snake_direction == LEFT)) {
                snake_direction = UP;
            }
            break;
        case "ArrowDown":
            if ((snake_direction == RIGHT) || (snake_direction == LEFT)) {
                snake_direction = DOWN;
            }
            break;
        case "`":
            show_debug = !show_debug;
            break;
    }
}

// Main part of the program
initialize_board();
initialize_level();
Initialize_snake();
copy_snake_to_board(LIVE_SNAKE);

setInterval(refresh_board, 50);
setInterval(snake_update, 100);
document.addEventListener('keydown', keyHandler);

</script>

</body>
</html> 